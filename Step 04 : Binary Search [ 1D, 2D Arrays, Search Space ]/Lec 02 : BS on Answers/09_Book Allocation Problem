import java.util.Arrays;

class Solution {
//link:-https://www.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1
    // =========================================================================
    //  TITLE:
    //  Book Allocation Problem
    // =========================================================================
    //
    //  PROBLEM STATEMENT:
    //  ------------------
    //  You are given an array `arr` where arr[i] represents the number of pages
    //  in the i-th book. There are `k` students.
    //
    //  Each student must be allocated at least one book.
    //  Books must be allocated in contiguous order.
    //
    //  The task is to minimize the maximum number of pages assigned to
    //  any student.
    //
    // =========================================================================
    //  INTUITION:
    //  ----------
    //  • If we allow very few pages per student, allocation may not be possible.
    //  • If we allow more pages, allocation becomes easier.
    //  • Feasibility of allocation is MONOTONIC with respect to max pages.
    //
    //  Hence, we apply **Binary Search on the answer (maximum pages)**.
    //
    // =========================================================================
    //  APPROACH (BINARY SEARCH + GREEDY):
    //  ---------------------------------
    //  1. Search space for maximum pages:
    //        • Minimum = maximum pages in a single book
    //        • Maximum = sum of all pages
    //
    //  2. For a given `mid` (maximum pages allowed):
    //        • Distribute books greedily to students
    //        • Start a new student whenever pages exceed `mid`
    //
    //  3. If books can be distributed using ≤ k students:
    //        • Try a smaller value of `mid`
    //     Else:
    //        • Increase `mid`
    //
    // =========================================================================
    //  EXAMPLE:
    //  --------
    //      arr = [12, 34, 67, 90], k = 2
    //
    //      Possible allocation:
    //      [12, 34, 67] | [90]
    //
    //      Maximum pages = 113 (minimum possible)
    //
    // =========================================================================
    //  DRY RUN:
    //  --------
    //      l = 90, r = 203
    //      mid = 146 → possible → ans = 146, r = 145
    //      mid = 117 → possible → ans = 117, r = 116
    //      mid = 103 → not possible → l = 104
    //      mid = 113 → possible → ans = 113
    //
    // =========================================================================
    //  KEY POINTS:
    //  ------------
    //  ✔ Books must be allocated contiguously
    //  ✔ Greedy check ensures feasibility
    //  ✔ Binary Search guarantees optimal result
    //
    // =========================================================================
    //  TIME COMPLEXITY:
    //      O(n log(sum(arr)))
    //
    //  SPACE COMPLEXITY:
    //      O(1)
    //
    // =========================================================================


    // -------------------------------------------------------------------------
    // METHOD NAME: canDistribute
    // PURPOSE    : Checks if books can be distributed with
    //              maximum pages per student = mid
    // -------------------------------------------------------------------------
    private boolean canDistribute(int[] arr, int mid, int k) {

        int sum = arr[0];   // pages assigned to current student
        int student = 1;    // number of students used

        // Allocate books sequentially
        for (int i = 1; i < arr.length; i++) {

            sum += arr[i];

            // If current student exceeds page limit,
            // assign book to next student
            if (sum > mid) {
                student++;
                sum = arr[i];
            }
        }

        // Allocation is valid if students used ≤ k
        return student <= k;
    }

    // -------------------------------------------------------------------------
    // METHOD NAME: findPages
    // PURPOSE    : Finds the minimum possible maximum pages
    // -------------------------------------------------------------------------
    public int findPages(int[] arr, int k) {

        // Edge case: more students than books
        if (arr.length < k) return -1;

        // Binary search boundaries
        int l = Arrays.stream(arr).max().getAsInt(); // minimum pages
        int r = Arrays.stream(arr).sum();            // maximum pages
        int ans = r;

        // Binary Search on maximum pages
        while (l <= r) {

            int mid = l + (r - l) / 2;

            if (canDistribute(arr, mid, k)) {
                ans = mid;        // store valid answer
                r = mid - 1;      // try smaller maximum
            } else {
                l = mid + 1;      // increase maximum
            }
        }

        return ans;
    }
}
