class Solution {
//link:-https://www.geeksforgeeks.org/problems/number-of-occurrence2259/1
    /*
     * =========================================================================
     *  TITLE: Count Frequency of a Target in a Sorted Array
     * =========================================================================
     *
     *  PROBLEM STATEMENT:
     *      Given a sorted array 'arr' and an integer 'target',
     *      return how many times the target appears in the array.
     *
     *      Example:
     *          arr = [1,2,2,2,3,4], target = 2
     *          Frequency = 3
     *
     *      If the target does not exist → return 0.
     *
     * =========================================================================
     *  INTUITION:
     *
     *      Since the array is sorted, all occurrences of the target
     *      appear in a **contiguous block**.
     *
     *      So:
     *          Frequency = last_occurrence_index - first_occurrence_index + 1
     *
     *      To find first and last positions efficiently, we use **binary search**
     *      instead of linear scanning.
     *
     * =========================================================================
     *  APPROACH:
     *
     *      Step 1 → findFirstPos():
     *          Use binary search to find the FIRST index at which target appears.
     *          - If nums[mid] == target → store mid, move LEFT to find earlier occurrence.
     *
     *      Step 2 → findLastPos():
     *          Use binary search to find the LAST index at which target appears.
     *          - If nums[mid] == target → store mid, move RIGHT to find later occurrence.
     *
     *      Step 3:
     *          If firstPos == -1 → target does not exist → return 0.
     *          Else → return (lastPos - firstPos + 1).
     *
     * =========================================================================
     *  EXAMPLE:
     *
     *      arr = [1, 2, 2, 2, 3, 5], target = 2
     *
     *      First occurrence  = index 1
     *      Last  occurrence  = index 3
     *
     *      Frequency = 3 - 1 + 1 = 3
     *
     * =========================================================================
     *  DRY RUN (First Position Search for target = 2):
     *
     *      arr = [1, 2, 2, 2, 3, 5]
     *
     *      s=0 e=5 → mid=2  → arr[2]=2 → ans=2, e=1
     *      s=0 e=1 → mid=0  → arr[0]=1 <2 → s=1
     *      s=1 e=1 → mid=1  → arr[1]=2 → ans=1, e=0
     *
     *      FIRST = 1
     *
     *
     *  DRY RUN (Last Position Search for target = 2):
     *
     *      s=0 e=5 → mid=2 → arr[2]=2 → ans=2, s=3
     *      s=3 e=5 → mid=4 → arr[4]=3 >2 → e=3
     *      s=3 e=3 → mid=3 → arr[3]=2 → ans=3, s=4
     *
     *      LAST = 3
     *
     *      Frequency = 3 - 1 + 1 = 3
     *
     * =========================================================================
     *  KEY POINTS:
     *
     *      ✔ Sorted array → binary search is optimal.
     *      ✔ First occurrence → search left when target found.
     *      ✔ Last occurrence → search right when target found.
     *      ✔ If first occurrence = -1 → target not found.
     *      ✔ Frequency computed in O(1) after two binary searches.
     *
     * =========================================================================
     *  SPECIAL NOTES:
     *
     *      - Binary search ensures O(log n) efficiency.
     *      - The trick is modifying binary search instead of stopping early.
     *      - Using two separate searches is simpler and avoids edge-case bugs.
     *
     * =========================================================================
     *  TIME COMPLEXITY:
     *      Two binary searches → O(log n)
     *
     *  SPACE COMPLEXITY:
     *      O(1) → no extra space used
     * =========================================================================
     */

    // -----------------------------------------
    // FIND FIRST OCCURRENCE OF TARGET
    // -----------------------------------------
    private static int findFirstPos(int[] nums, int target) {
        int s = 0, e = nums.length - 1;
        int ans = -1;

        while (s <= e) {
            int mid = s + (e - s) / 2;

            if (nums[mid] == target) {
                ans = mid;      // store candidate
                e = mid - 1;    // search LEFT side for earlier occurrence
            }
            else if (target > nums[mid]) {
                s = mid + 1;    // target lies on the RIGHT
            }
            else {
                e = mid - 1;    // target lies on the LEFT
            }
        }

        return ans;
    }

    // -----------------------------------------
    // FIND LAST OCCURRENCE OF TARGET
    // -----------------------------------------
    private static int findLastPos(int[] nums, int target) {
        int s = 0, e = nums.length - 1;
        int ans = -1;

        while (s <= e) {
            int mid = s + (e - s) / 2;

            if (nums[mid] == target) {
                ans = mid;      // store candidate
                s = mid + 1;    // search RIGHT side for later occurrence
            }
            else if (target > nums[mid]) {
                s = mid + 1;    // go RIGHT
            }
            else {
                e = mid - 1;    // go LEFT
            }
        }

        return ans;
    }

    // -----------------------------------------
    // MAIN FUNCTION: RETURN FREQUENCY
    // -----------------------------------------
    int countFreq(int[] arr, int target) {

        int firstPos = findFirstPos(arr, target);

        // If first occurrence does not exist → target not in array
        if (firstPos == -1) return 0;

        int lastPos = findLastPos(arr, target);

        // Frequency = last - first + 1
        return lastPos - firstPos + 1;
    }
}
