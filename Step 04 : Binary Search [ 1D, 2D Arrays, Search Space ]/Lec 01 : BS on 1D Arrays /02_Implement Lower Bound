class Solution {

    /*
     * =========================================================================
     *  TITLE: Binary Search â€“ Lower Bound
     * =========================================================================
     *
     *  PROBLEM STATEMENT:
     *      Given a sorted array 'arr' and a value 'target',
     *      return the index of the **first element that is >= target**.
     *
     *      If no such element exists, return n (array length).
     *
     *      This replicates the behavior of:
     *          C++: lower_bound(arr, arr+n, target)
     *
     * =========================================================================
     *  INTUITION:
     *
     *      We apply binary search to find the earliest index where:
     *
     *              arr[mid] >= target
     *
     *      When this condition is true, mid *could* be the answer,
     *      but we still search the **left half** to find if there
     *      exists an even earlier index satisfying the condition.
     *
     *      If arr[mid] < target, then the required index must lie
     *      in the **right half**.
     *
     * =========================================================================
     *  SPECIAL NOTE:
     *
     *      - The array MUST be sorted.
     *      - 'ans' starts as n, meaning "not found yet".
     *      - The moment arr[mid] >= target, mid becomes a candidate.
     *
     * =========================================================================
     *  TIME COMPLEXITY:  O(log n)
     *  SPACE COMPLEXITY: O(1)
     * =========================================================================
     */

    int lowerBound(int[] arr, int target) {
        
        int n = arr.length;
        int s = 0;
        int e = n - 1;

        int ans = n;  // Default: target is greater than all elements

        while (s <= e) {

            int mid = s + (e - s) / 2;

            // If arr[mid] >= target, mid might be the lower bound
            if (arr[mid] >= target) {
                ans = mid;      // store potential index
                e = mid - 1;    // search left half for earlier candidate
            }
            else {
                s = mid + 1;    // search right half
            }
        }

        return ans;
    }
}
