/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    /**
     * Title: Same Tree
     *
     * Description:
     * ------------
     * Determines whether two binary trees are identical.
     * Two binary trees are considered the same if:
     *  1. They have the same structure.
     *  2. The corresponding nodes have the same values.
     *
     * Approach:
     * ---------
     * - Use recursion:
     *    1. If both nodes are null → return true.
     *    2. If one node is null and the other is not → return false.
     *    3. If values differ → return false.
     *    4. Recursively check left subtrees and right subtrees.
     *
     * Key Points:
     * -----------
     * - This is a straightforward DFS (Depth First Search).
     * - Base case is when both nodes are null (trees are identical so far).
     *
     * Example:
     * --------
     * Tree p:        1           Tree q:        1
     *               / \                        / \
     *              2   3                      2   3
     *
     * Both trees have identical structure and values → return true.
     *
     * Time Complexity: O(n)
     *   - Each node is visited once (n = number of nodes in smaller tree).
     *
     * Space Complexity: O(h)
     *   - h = height of tree (recursion stack).
     *   - Worst case O(n) for skewed tree, O(log n) for balanced tree.
     */
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // Case 1: both nodes are null → trees are identical here
        if (p == null && q == null) {
            return true;
        }

        // Case 2: one is null but not the other → structure mismatch
        if (p == null || q == null) {
            return false;
        }

        // Case 3: values mismatch → trees differ
        if (p.val != q.val) {
            return false;
        }

        // Recursively check left and right subtrees
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
