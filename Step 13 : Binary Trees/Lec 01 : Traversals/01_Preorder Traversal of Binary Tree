// Link: https://leetcode.com/problems/binary-tree-preorder-traversal/

/*
===========================================================
TITLE
===========================================================
Binary Tree Preorder Traversal (Recursive)

===========================================================
PROBLEM STATEMENT
===========================================================
You are given the root of a binary tree.

Your task is to return the **preorder traversal** of the tree’s nodes’ values.

Preorder Traversal Order:
• Root → Left → Right

Input:
• TreeNode root → root of the binary tree

Output:
• List<Integer> → values of nodes in preorder traversal order

Constraints:
• Number of nodes in the tree: 0 ≤ n ≤ 100
• -100 ≤ Node.val ≤ 100

Edge Cases:
• Empty tree (root == null)
• Tree with only one node
• Left-skewed tree
• Right-skewed tree

===========================================================
INTUITION
===========================================================
• Preorder traversal always processes the root before its subtrees
• Recursion naturally matches the tree structure
• For each node:
  - Visit the node
  - Traverse left subtree
  - Traverse right subtree

===========================================================
APPROACH (RECURSION)
===========================================================
1) Create a helper recursive function:
   - If current node is null, return
   - Add current node value to result list
   - Recursively traverse left subtree
   - Recursively traverse right subtree

2) Call the helper function starting from the root

===========================================================
EXAMPLE
===========================================================
Input Tree:
        1
         \
          2
         /
        3

Preorder Traversal:
Root → Left → Right

Steps:
Visit 1
Visit 2
Visit 3

Output:
[1, 2, 3]

===========================================================
TIME COMPLEXITY
===========================================================
O(n)
• Each node is visited exactly once

===========================================================
SPACE COMPLEXITY
===========================================================
O(n)
• Recursive call stack in worst case (skewed tree)
• Output list stores n elements

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• Recursive solution is simple and intuitive
• Stack overflow may occur for very deep trees
• Iterative approach using stack is an alternative
===========================================================
*/

import java.util.*;

class Solution {

    /*
     * Helper function to perform preorder traversal
     * Traversal order: Root → Left → Right
     */
    private void preorder(TreeNode root, List<Integer> list) {

        // Base case: if current node is null, stop recursion
        if (root == null) return;

        // Step 1: Visit the root node
        list.add(root.val);

        // Step 2: Traverse left subtree
        preorder(root.left, list);

        // Step 3: Traverse right subtree
        preorder(root.right, list);
    }

    /*
     * Returns the preorder traversal of a binary tree
     */
    public List<Integer> preorderTraversal(TreeNode root) {

        // List to store traversal result
        List<Integer> result = new ArrayList<>();

        // Start preorder traversal from root
        preorder(root, result);

        return result;
    }
}
