/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

import java.util.*;

class Solution {

    /*
     -------------------------------------------------------------
     Title: Level Order Traversal (Breadth-First Search)
     -------------------------------------------------------------
     Problem:
     Given the root of a binary tree, return its level order
     traversal. Each level of the tree should be returned as a
     separate list.

     Example:
     --------
     Input Tree:
            1
           / \
          2   3
         / \
        4   5

     Output:
     [
       [1],
       [2, 3],
       [4, 5]
     ]

     Approach:
     ---------
     Use a queue to perform a BFS traversal. Each iteration of BFS
     processes exactly one level of the tree.

     Steps:
     1. If root is null â†’ return empty list.
     2. Push root into the queue.
     3. While queue is not empty:
        - Determine the number of nodes in the current level.
        - Remove exactly that many nodes from the queue.
        - Add their values to a list for this level.
        - Push their children (if any) into the queue.
     4. Append each level list to the final result.

     Time Complexity:  O(N)
        Each node is visited exactly once.

     Space Complexity: O(N)
        Queue may hold at most one level of nodes.

     -------------------------------------------------------------
    */

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();

        // Base case: empty tree
        if (root == null) return result;

        // Queue to support BFS traversal
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);

        // BFS: process nodes level by level
        while (!q.isEmpty()) {
            int size = q.size();           // Number of nodes in the current level
            List<Integer> level = new ArrayList<>();

            // Process all nodes of this level
            for (int i = 0; i < size; i++) {
                TreeNode currNode = q.poll(); // Pop front node
                level.add(currNode.val);      // Append node value

                // Add children for next level
                if (currNode.left != null)  q.add(currNode.left);
                if (currNode.right != null) q.add(currNode.right);
            }

            // Add this level to the result
            result.add(level);
        }

        return result;
    }
}
