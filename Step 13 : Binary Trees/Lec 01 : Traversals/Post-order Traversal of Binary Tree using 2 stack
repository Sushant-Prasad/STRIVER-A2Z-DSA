/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    /**
     * Title: Iterative Postorder Traversal using Two Stacks
     *
     * @param root Root node of the binary tree
     * @return A list of integers representing the postorder traversal (Left → Right → Root)
     *
     * Approach:
     * ---------
     * 1. Use two stacks (s1 and s2).
     *    - Push the root into s1.
     *    - While s1 is not empty:
     *        a) Pop from s1 → call it "current".
     *        b) Push "current" into s2.
     *        c) Push left child (if exists) into s1.
     *        d) Push right child (if exists) into s1.
     *
     * 2. After s1 is empty, s2 contains nodes in the order Root → Right → Left.
     *
     * 3. Pop all nodes from s2 and add their values to result list.
     *    - This reverses the order to Left → Right → Root (postorder).
     *
     * Example:
     * --------
     * Input Tree: 
     *        1
     *       / \
     *      2   3
     * Postorder Traversal → [2, 3, 1]
     *
     * Time Complexity: O(n) 
     *   - Each node is pushed and popped at most twice.
     *
     * Space Complexity: O(n) 
     *   - Two stacks store up to n nodes in the worst case.
     */
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;

        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();

        // Step 1: Push root into the first stack
        s1.push(root);

        // Step 2: Process all nodes
        while (!s1.isEmpty()) {
            root = s1.pop();    // take out from s1
            s2.push(root);      // push into s2

            // Push children into s1
            if (root.left != null) s1.push(root.left);
            if (root.right != null) s1.push(root.right);
        }

        // Step 3: Pop all nodes from s2 to get postorder
        while (!s2.isEmpty()) {
            res.add(s2.pop().val);
        }

        return res;
    }
}
