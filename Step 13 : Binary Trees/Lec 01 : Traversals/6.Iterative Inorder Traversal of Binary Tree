/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

import java.util.*;

class Solution {
    /**
     * Function to perform Inorder Traversal (iterative).
     * Inorder traversal order: Left → Root → Right
     *
     * Approach (Using Stack):
     * -----------------------
     * 1. Create an empty stack and set a pointer `node = root`.
     * 2. Traverse left subtree until null:
     *    - Push each node into the stack while moving left.
     * 3. When left is null:
     *    - Pop from stack → this is the current node to process (visit).
     *    - Add its value to result.
     *    - Move to its right subtree (node = node.right).
     * 4. Repeat until both `stack` is empty and `node` is null.
     *
     * Example:
     * Tree:        1
     *             / \
     *            2   3
     *           / \
     *          4   5
     *
     * Inorder = [4, 2, 5, 1, 3]
     *
     * Time Complexity: O(n) → each node is pushed and popped once.
     * Space Complexity: O(h) → stack stores nodes along one path (h = tree height).
     */
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> s = new Stack<>();
        TreeNode node = root;

        // Traverse until stack empty and node is null
        while (node != null || !s.isEmpty()) {
            // Step 1: Go as left as possible
            while (node != null) {
                s.push(node);
                node = node.left;
            }

            // Step 2: Process node
            node = s.pop();
            res.add(node.val);

            // Step 3: Move to right subtree
            node = node.right;
        }

        return res;
    }
}
