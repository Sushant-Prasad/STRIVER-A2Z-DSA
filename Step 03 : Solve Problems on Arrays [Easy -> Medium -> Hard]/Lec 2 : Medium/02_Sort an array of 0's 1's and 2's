# Method-1
/*
Title: Sort Colors (Counting Sort Approach)
-------------------------------------------
Problem Statement:
Given an array `nums` containing only 0s, 1s, and 2s, 
sort the array in-place so that all 0s come first, 
followed by 1s, and then 2s.

You must solve this problem without using any built-in sorting library.

Example:
--------
Input:  nums = [2, 0, 2, 1, 1, 0]
Output: [0, 0, 1, 1, 2, 2]

Approach (Counting Sort Logic):
-------------------------------
1. Count the occurrences of each value (0, 1, and 2) in the array.
   - Use three counters: `count0`, `count1`, `count2`.
2. In a single loop, overwrite the array:
   - The first `count0` elements should be 0.
   - The next `count1` elements should be 1.
   - The remaining elements should be 2.

This approach uses two passes:
   - First pass to count each number.
   - Second pass to overwrite the array.

Dry Run:
--------
nums = [2, 0, 2, 1, 1, 0]

Counting phase:
count0 = 2, count1 = 2, count2 = 2

Overwriting phase:
Indices 0..1 → 0
Indices 2..3 → 1
Indices 4..5 → 2
Result: [0, 0, 1, 1, 2, 2]

Time Complexity:  O(n)
   - Two linear passes over the array.

Space Complexity: O(1)
   - Constant extra space used for counters only.
*/

class Solution {
    public void sortColors(int[] nums) {
        int count0 = 0, count1 = 0, count2 = 0;

        // Step 1: Count occurrences of 0, 1, and 2
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) count0++;
            if (nums[i] == 1) count1++;
            if (nums[i] == 2) count2++;
        }

        // Step 2: Overwrite the array in one pass
        for (int i = 0; i < nums.length; i++) {
            if (i < count0) nums[i] = 0;
            else if (i < count0 + count1) nums[i] = 1;
            else nums[i] = 2;
        }
    }
}

# Method-2

/*
Title: Sort Colors (Dutch National Flag Algorithm)
--------------------------------------------------
Problem Statement:
Given an array `nums` containing only 0s, 1s, and 2s, 
sort the array in-place so that all 0s come first, 
then all 1s, and finally all 2s.

You must solve this problem without using any built-in sorting library.

Example:
--------
Input:  nums = [2, 0, 2, 1, 1, 0]
Output: [0, 0, 1, 1, 2, 2]

Approach (Dutch National Flag - One Pass, In-Place):
----------------------------------------------------
We use three pointers: `i`, `j`, and `k` to partition the array.

1. `i` → next position for 0 (starts at 0)
2. `j` → current index being inspected (it is for 1)
3. `k` → next position for 2 (starts at end)

Algorithm:
-----------
- Traverse the array while `j <= k`:
   • If `nums[j] == 0`:
        → Swap nums[i] and nums[j]
        → Increment both `i` and `j`
   • If `nums[j] == 1`:
        → Just move `j` forward
   • If `nums[j] == 2`:
        → Swap nums[j] and nums[k]
        → Decrement `k` only (since swapped element needs to be checked)

This ensures all 0s move to the left, 2s move to the right,
and 1s remain in the middle.

Dry Run:
--------
nums = [2, 0, 2, 1, 1, 0]
Initial: i=0, j=0, k=5

Step 1: nums[j]=2 → swap(nums[j], nums[k]) → [0, 0, 2, 1, 1, 2], k=4
Step 2: nums[j]=0 → swap(nums[i], nums[j]) → [0, 0, 2, 1, 1, 2], i=1, j=1
Step 3: nums[j]=0 → swap(nums[i], nums[j]) → [0, 0, 2, 1, 1, 2], i=2, j=2
Step 4: nums[j]=2 → swap(nums[j], nums[k]) → [0, 0, 1, 1, 2, 2], k=3
Step 5: nums[j]=1 → j++
Step 6: nums[j]=1 → j++
Stop when j > k

Result → [0, 0, 1, 1, 2, 2]

Time Complexity:  O(n)
   - Single traversal of the array.

Space Complexity: O(1)
   - In-place swapping, no extra data structure used.
*/

class Solution {
    public void sortColors(int[] nums) {
        int i = 0;                  // Pointer for next 0 position
        int j = 0;                  // Current element under inspection (it is for 1)
        int k = nums.length - 1;    // Pointer for next 2 position

        while (j <= k) {
            if (nums[j] == 1) {
                // Leave 1s in the middle
                j++;
            } 
            else if (nums[j] == 0) {
                // Swap 0 to the front
                int temp = nums[j];
                nums[j] = nums[i];
                nums[i] = temp;
                i++;
                j++;
            } 
            else { // nums[j] == 2
                // Swap 2 to the end
                int temp = nums[j];
                nums[j] = nums[k];
                nums[k] = temp;
                k--;
            }
        }
    }
}
