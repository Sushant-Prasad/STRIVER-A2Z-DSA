/*
Title: Leaders in an Array (Using inbuilt reverse method)
---------------------------------------------------------
Problem Statement:
Given an array `arr[]` of size `n`, find all the leaders in the array.

An element is called a "leader" if it is greater than or equal to 
all the elements to its right side in the array.
The rightmost element is always a leader.

Example:
--------
Input:  arr = [16, 17, 4, 3, 5, 2]
Output: [17, 5, 2]

Explanation:
- Starting from the right:
  - 2 → leader (no element to its right)
  - 5 ≥ 2 → leader
  - 3 < 5 → not a leader
  - 4 < 5 → not a leader
  - 17 ≥ 5 → leader
  - 16 < 17 → not a leader
  → Leaders (in original order): [17, 5, 2]

---------------------------------------------------------
Approach:
1. Traverse the array from right to left.
2. Keep track of the maximum element seen so far (`max`).
3. If `arr[i] >= max`, then arr[i] is a leader:
   - Add it to a result list and update `max`.
4. After traversal, reverse the list using 
   Java’s inbuilt `Collections.reverse()` to restore original order.

---------------------------------------------------------
Time Complexity:  O(n)
   - Single pass + O(m) for reversal (m ≤ n)
Space Complexity: O(n)
   - To store leaders
*/

import java.util.ArrayList;
import java.util.Collections;

class Solution {

    static ArrayList<Integer> leaders(int arr[]) {
        int n = arr.length;
        ArrayList<Integer> res = new ArrayList<>();

        // Last element is always a leader
        int max = arr[n - 1];
        res.add(max);

        // Traverse from right to left and collect leaders
        for (int i = n - 2; i >= 0; i--) {
            if (arr[i] >= max) {
                res.add(arr[i]);
                max = arr[i];
            }
        }

        // Reverse list to restore left-to-right order using inbuilt method
        Collections.reverse(res);

        return res;
    }
}
