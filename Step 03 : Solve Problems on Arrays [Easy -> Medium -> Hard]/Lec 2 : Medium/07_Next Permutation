/*
Title: Next Permutation
-----------------------
Problem Statement:
Implement the next permutation of the given integer array `nums` in lexicographical order.
The replacement must be done in-place and use only constant extra memory.

If no next permutation exists (i.e., the array is sorted in descending order),
transform it into the smallest possible permutation (ascending order).

Example:
--------
Input:  nums = [1, 2, 3]
Output: [1, 3, 2]

Explanation:
All permutations of [1,2,3] in lexicographic order:
[1,2,3] → [1,3,2] → [2,1,3] → [2,3,1] → [3,1,2] → [3,2,1]
The next permutation after [1,2,3] is [1,3,2].

-------------------------------------------------------
Approach (Lexicographic Next Permutation Algorithm):
-------------------------------------------------------
The goal is to rearrange the array into the next lexicographically greater permutation.

1. **Find the Pivot (Decreasing Point):**
   - Traverse from right to left and find the first index `pivot` 
     such that `nums[pivot] < nums[pivot + 1]`.
   - This identifies where the next permutation must change.
   - If no such pivot exists (array is entirely non-increasing), 
     it means we’re at the last permutation, so reverse the array.

2. **Find the Rightmost Successor:**
   - From the right end, find the smallest element greater than `nums[pivot]`
     (this is the next larger element that can replace `nums[pivot]`).

3. **Swap Pivot and Successor:**
   - Swap these two elements to create a slightly larger prefix.

4. **Reverse the Suffix:**
   - Finally, reverse the subarray to the right of the pivot (i.e., `nums[pivot + 1 ... n - 1]`),
     so that it becomes the smallest possible sequence.

-------------------------------------------------------
Dry Run Example:
-------------------------------------------------------
nums = [1, 2, 3]
Step 1: Pivot = 1 (nums[1] < nums[2])
Step 2: Rightmost successor > nums[1] = nums[2] (3)
Step 3: Swap → [1, 3, 2]
Step 4: Reverse suffix (after pivot + 1) → [1, 3, 2]
Result = [1, 3, 2]

nums = [3, 2, 1]
Pivot not found → reverse entire array → [1, 2, 3]

-------------------------------------------------------
Time Complexity:  O(n)
   - Single traversal to find pivot and successor, plus O(n) for reversing the suffix.

Space Complexity: O(1)
   - In-place swaps, no extra data structure used.
*/

class Solution {

    // Utility: Reverse subarray arr[s..e] inclusive
    private void reverse(int[] arr, int s, int e) {
        while (s < e) {
            int temp = arr[s];
            arr[s] = arr[e];
            arr[e] = temp;
            s++;
            e--;
        }
    }

    public void nextPermutation(int[] nums) {
        int n = nums.length;

        // 1) Find pivot: the largest index i such that nums[i] < nums[i + 1]
        int pivot = -1;
        for (int i = n - 1; i > 0; i--) {
            if (nums[i - 1] < nums[i]) {
                pivot = i - 1;
                break;
            }
        }

        // 2) If pivot found, find rightmost element greater than nums[pivot]
        if (pivot != -1) {
            int swapIndex = -1;
            for (int i = n - 1; i > pivot; i--) {
                if (nums[i] > nums[pivot]) {
                    swapIndex = i;
                    break;
                }
            }

            // Swap pivot and successor
            int temp = nums[pivot];
            nums[pivot] = nums[swapIndex];
            nums[swapIndex] = temp;
        }

        // 3) Reverse the suffix (to make it the smallest possible order)
        reverse(nums, pivot + 1, n - 1);
    }
}
