/*
===========================================================
TITLE
===========================================================
Next Permutation (Lexicographic Order)

===========================================================
PROBLEM STATEMENT
===========================================================
Given an integer array `nums`, rearrange it into the
**next lexicographically greater permutation**.

• The modification must be done **in-place**
• Use only **constant extra memory**

If the array is already in the **highest permutation**
(sorted in descending order), rearrange it into the
**lowest permutation** (ascending order).

===========================================================
INPUT FORMAT
===========================================================
• An integer array `nums`

===========================================================
OUTPUT FORMAT
===========================================================
• Modify the input array in-place
• No return value

===========================================================
EXAMPLE
===========================================================
Input:
nums = [1, 2, 3]

Output:
[1, 3, 2]

Explanation:
Lexicographic order:
[1,2,3] → [1,3,2] → [2,1,3] → [2,3,1] → [3,1,2] → [3,2,1]

===========================================================
INTUITION
===========================================================
To get the next permutation:
• We need to make the number **just slightly larger**
• Change should happen as far right as possible
• After the change, the remaining suffix should be the
  **smallest possible arrangement**

===========================================================
APPROACH (Lexicographic Algorithm)
===========================================================
1) Find the **pivot**:
   - Traverse from right to left
   - Find first index `pivot` such that:
     nums[pivot] < nums[pivot + 1]

2) If no pivot exists:
   - The array is in descending order
   - Reverse the entire array and stop

3) Find the **rightmost successor**:
   - From the end, find the first element
     greater than nums[pivot]

4) Swap pivot and successor

5) Reverse the suffix (pivot + 1 to end)
   - This gives the smallest possible order after pivot

===========================================================
DRY RUN
===========================================================
nums = [1, 2, 3]

Step 1: Find pivot
2 < 3 → pivot = 1

Step 2: Find successor
Rightmost > 2 is 3

Step 3: Swap
[1, 3, 2]

Step 4: Reverse suffix
Suffix already sorted → [1, 3, 2]

----------------------------------
nums = [3, 2, 1]
No pivot found → reverse entire array
Result: [1, 2, 3]

===========================================================
KEY POINTS
===========================================================
• Pivot identifies where the next permutation changes
• Rightmost successor ensures minimal increase
• Reversing suffix ensures smallest lexicographic order
• Works fully in-place

===========================================================
TIME COMPLEXITY
===========================================================
O(n)
- One pass to find pivot
- One pass to find successor
- One pass to reverse suffix

===========================================================
SPACE COMPLEXITY
===========================================================
O(1)
- No extra space used

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• Pivot = -1 means array is in highest permutation
• Reversal is crucial to reset suffix order
• Algorithm is standard and optimal
===========================================================
*/

class Solution {

    // Utility method to reverse a subarray from index s to e (inclusive)
    private void reverse(int[] arr, int s, int e) {
        while (s < e) {
            int temp = arr[s];
            arr[s] = arr[e];
            arr[e] = temp;
            s++;
            e--;
        }
    }

    public void nextPermutation(int[] nums) {

        int n = nums.length;

        // Step 1: Find pivot (first index from right where nums[i] < nums[i+1])
        int pivot = -1;
        for (int i = n - 1; i > 0; i--) {
            if (nums[i - 1] < nums[i]) {
                pivot = i - 1;
                break;
            }
        }

        // Step 2: If pivot exists, find rightmost successor and swap
        if (pivot != -1) {

            // Find the smallest element greater than nums[pivot] from the right
            for (int i = n - 1; i > pivot; i--) {
                if (nums[i] > nums[pivot]) {

                    // Swap pivot and successor
                    int temp = nums[pivot];
                    nums[pivot] = nums[i];
                    nums[i] = temp;
                    break;
                }
            }
        }

        // Step 3: Reverse the suffix to get the smallest arrangement
        reverse(nums, pivot + 1, n - 1);
    }
}
