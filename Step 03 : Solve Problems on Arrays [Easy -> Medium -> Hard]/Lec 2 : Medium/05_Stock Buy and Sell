/*
===========================================================
TITLE
===========================================================
Best Time to Buy and Sell Stock (Single Transaction)

===========================================================
PROBLEM STATEMENT
===========================================================
You are given an integer array `prices`, where:
• prices[i] represents the stock price on the i-th day.

You are allowed to perform **only one transaction**:
• Buy the stock on one day
• Sell the stock on a **future** day (sell day > buy day)

Your task is to return the **maximum profit** that can be achieved.
If no profit is possible, return `0`.

===========================================================
INPUT FORMAT
===========================================================
• An integer array `prices`

===========================================================
OUTPUT FORMAT
===========================================================
• An integer representing the maximum possible profit
• Return `0` if no profitable transaction exists

===========================================================
EXAMPLE
===========================================================
Input:
prices = [7, 1, 5, 3, 6, 4]

Output:
5

Explanation:
Buy on day 2 (price = 1)
Sell on day 5 (price = 6)
Profit = 6 - 1 = 5

===========================================================
INTUITION
===========================================================
To maximize profit:
• Always buy at the **lowest price seen so far**
• Try selling on each day and calculate profit
• Keep track of the **maximum profit** encountered

This can be done efficiently in a **single pass**.

===========================================================
APPROACH (Single Pass – Greedy)
===========================================================
1) Initialize:
   - `bp` (buy price) as a very large value
   - `maxProfit` as 0

2) Traverse the array:
   - If current price > bp:
       → Calculate profit = current price - bp
       → Update maxProfit if this profit is higher
   - Else:
       → Update bp with the current lower price

3) Return maxProfit

===========================================================
DRY RUN
===========================================================
prices = [7, 1, 5, 3, 6, 4]

Initial:
bp = ∞, maxProfit = 0

Day 0: price = 7
bp = 7

Day 1: price = 1
bp = 1

Day 2: price = 5
profit = 5 - 1 = 4 → maxProfit = 4

Day 3: price = 3
profit = 3 - 1 = 2 → maxProfit unchanged

Day 4: price = 6
profit = 6 - 1 = 5 → maxProfit = 5

Day 5: price = 4
profit = 4 - 1 = 3 → maxProfit unchanged

Final Answer = 5

===========================================================
KEY POINTS
===========================================================
• Buy must happen before sell
• Only one transaction allowed
• Greedy approach works optimally here
• Tracks minimum price so far and best profit

===========================================================
TIME COMPLEXITY
===========================================================
O(n)
- Only one traversal of the array

===========================================================
SPACE COMPLEXITY
===========================================================
O(1)
- Uses constant extra space

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• `bp` always stores the minimum price up to the current day
• Profit is only calculated when selling price > buy price
• If prices are strictly decreasing, result remains 0
===========================================================
*/

class Solution {

    public int maxProfit(int[] prices) {

        int n = prices.length;

        int bp = Integer.MAX_VALUE; // Stores the minimum (best) buying price so far
        int maxProfit = 0;          // Stores the maximum profit found

        // Traverse prices array once
        for (int i = 0; i < n; i++) {

            if (prices[i] > bp) {
                // If selling today gives profit, calculate it
                int profit = prices[i] - bp;

                // Update maximum profit if current profit is better
                maxProfit = Math.max(maxProfit, profit);

            } else {
                // Found a new lower price to buy
                bp = prices[i];
            }
        }

        // Return the maximum profit possible
        return maxProfit;
    }
}
