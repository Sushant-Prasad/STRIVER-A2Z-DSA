class Solution {

    /*
     * =========================================================================
     *     493. Reverse Pairs  —  Using Modified Merge Sort
     * =========================================================================
     *
     *  PROBLEM STATEMENT:
     *  Count pairs (i, j) where:
     *
     *         i < j   AND   nums[i] > 2 * nums[j]
     *
     *  A brute-force approach takes O(n²), which is too slow.
     *
     *  We use Merge Sort because:
     *     - Left half is sorted
     *     - Right half is sorted
     *     - We can count valid reverse pairs in O(n) while merging
     *
     * =========================================================================
     *  SPECIAL NOTE ABOUT THIS CONDITION:
     *
     *               nums[left] > 2L * nums[right]
     *
     *  WHY "2L"?
     *     - nums[i] and nums[j] can be as large as 2^31 - 1
     *     - Multiplying by 2 may overflow a 32-bit integer
     *     - Using "2L" promotes the multiplication to LONG
     *       preventing overflow and ensuring correct comparison.
     *
     * =========================================================================
     */

    private static int merge(int[] nums , int l , int mid , int r) {

        int left = l;
        int right = mid + 1;
        int pair = 0;

        // -------------------------------------------------------
        // 1️⃣ COUNT REVERSE PAIRS USING TWO POINTERS
        // -------------------------------------------------------
        while (left <= mid && right <= r) {

            // If nums[left] > 2 * nums[right], then all elements
            // nums[left ... mid] are greater than 2 * nums[right].
            if (nums[left] > 2L * nums[right]) {
                pair += (mid - left + 1);
                right++;
            } else {
                left++;
            }
        }

        // -------------------------------------------------------
        // 2️⃣ MERGE THE TWO SORTED HALVES (NORMAL MERGE SORT)
        // -------------------------------------------------------
        int i = l;
        int j = mid + 1;
        ArrayList<Integer> temp = new ArrayList<>();

        while (i <= mid && j <= r) {
            if (nums[i] > nums[j]) {
                temp.add(nums[j]);
                j++;
            } else {
                temp.add(nums[i]);
                i++;
            }
        }

        // Add remaining elements from left half
        while (i <= mid) {
            temp.add(nums[i]);
            i++;
        }

        // Add remaining elements from right half
        while (j <= r) {
            temp.add(nums[j]);
            j++;
        }

        // Copy merged values back to nums[l..r]
        for (int k = 0; k < temp.size(); k++) {
            nums[l + k] = temp.get(k);
        }

        return pair;
    }


    /*
     * Merge sort recursively divides the array, sorts it,
     * and counts reverse pairs in each half + while merging.
     */
    private static int mergeSort(int[] nums, int l, int r) {
        if (l >= r) return 0;

        int mid = l + (r - l) / 2;

        int leftPairs  = mergeSort(nums, l, mid);
        int rightPairs = mergeSort(nums, mid + 1, r);

        int crossPairs = merge(nums, l, mid, r);

        return leftPairs + rightPairs + crossPairs;
    }


    /*
     * Public method that initiates merge sort and returns the result.
     */
    public int reversePairs(int[] nums) {
        return mergeSort(nums, 0, nums.length - 1);
    }
}
