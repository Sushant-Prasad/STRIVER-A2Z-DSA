class Solution {

    /*
     * ------------------------------------------------------------------------
     *  TITLE: Merge Sorted Array (LeetCode 88)
     * ------------------------------------------------------------------------
     *  PROBLEM STATEMENT:
     *  Given two sorted arrays:
     *
     *      nums1 has size m + n, where the first m elements are valid,
     *      and nums2 has n valid elements.
     *
     *  Merge nums2 into nums1 as one sorted array IN-PLACE.
     *
     *  nums1 has enough extra space at the end to hold all nums2 elements.
     *
     * ------------------------------------------------------------------------
     *  APPROACH (Two Pointers from the End):
     *
     *  - Use three pointers:
     *        p1 → last valid index in nums1 (m - 1)
     *        p2 → last index in nums2 (n - 1)
     *        i  → last position in nums1 (m + n - 1)
     *
     *  - Compare nums1[p1] and nums2[p2]:
     *        - Place the larger element at nums1[i]
     *        - Move the corresponding pointer backward
     *
     *  - Continue until nums2 is fully exhausted.
     *
     *  NOTE:
     *  - We only need to check p2 >= 0, because if nums2 finishes,
     *    nums1 is already correctly placed.
     *
     * ------------------------------------------------------------------------
     *  TIME COMPLEXITY: O(m + n)
     *  SPACE COMPLEXITY: O(1)  (in-place merge)
     * ------------------------------------------------------------------------
     */

    public void merge(int[] nums1, int m, int[] nums2, int n) {

        int p1 = m - 1;        // pointer for nums1 valid elements
        int p2 = n - 1;        // pointer for nums2
        int i = m + n - 1;     // pointer for placement from end of nums1

        // Process nums2 until all elements are placed
        while (p2 >= 0) {

            // If nums1 still has elements AND nums1[p1] > nums2[p2]
            if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[i] = nums1[p1];   // place nums1 element
                p1--;                   // move p1 backward
            } else {
                nums1[i] = nums2[p2];   // place nums2 element
                p2--;                   // move p2 backward
            }

            i--;  // move placement pointer backward
        }
    }
}
