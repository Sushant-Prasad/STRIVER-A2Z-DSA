class Solution {

/*
===========================================================
TITLE
===========================================================
Remove Duplicates from Sorted Array (In-Place)

===========================================================
PROBLEM STATEMENT
===========================================================
You are given a **sorted integer array `nums`**.

Your task is to remove duplicate elements **in-place** such that each unique
element appears only once.

The relative order of the elements should be preserved.

After removing duplicates:
• Return the number of unique elements
• The first `k` elements of the array should contain the unique values
• Remaining elements are irrelevant

Input:
• int[] nums → sorted array

Output:
• int → number of unique elements

Constraints:
• 0 ≤ nums.length ≤ 10⁵
• -10⁴ ≤ nums[i] ≤ 10⁴
• Array is sorted in non-decreasing order

Edge Cases:
• Empty array
• Array with only one element
• All elements same
• All elements already unique

===========================================================
INTUITION
===========================================================
• Since the array is sorted, duplicates appear consecutively
• We only need to compare each element with the last unique element
• Two-pointer technique allows in-place modification with O(1) space

===========================================================
APPROACH
===========================================================
1) If array is empty, return 0
2) Use pointer `j` to track position of next unique element
3) Traverse array from index 1:
   - If nums[i] ≠ nums[j - 1], place nums[i] at nums[j]
   - Increment `j`
4) At the end, `j` represents number of unique elements

===========================================================
EXAMPLE
===========================================================
Input:
nums = [1, 1, 2, 2, 3]

Process:
i=1 → 1 == 1 → skip
i=2 → 2 ≠ 1 → nums[1] = 2 → j=2
i=3 → 2 == 2 → skip
i=4 → 3 ≠ 2 → nums[2] = 3 → j=3

Result:
Unique count = 3
Array = [1, 2, 3, _, _]

===========================================================
TIME COMPLEXITY
===========================================================
O(n)
• Single pass through the array

===========================================================
SPACE COMPLEXITY
===========================================================
O(1)
• In-place modification, no extra space used

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• Works only because array is sorted
• Two-pointer approach ensures optimal performance
• Index `j-1` always points to last unique element
===========================================================
*/

    /*
     * Removes duplicates from a sorted array in-place
     * Returns the number of unique elements
     */
    public int removeDuplicates(int[] nums) {

        int n = nums.length;

        // Handle empty array
        if (n == 0) return 0;

        // Pointer for next unique element
        int j = 1;

        // Traverse array starting from second element
        for (int i = 1; i < n; i++) {

            // If current element is different from last unique element
            if (nums[i] != nums[j - 1]) {

                // Place current element at correct position
                nums[j] = nums[i];

                // Move pointer forward
                j++;
            }
        }

        // j represents number of unique elements
        return j;
    }
}
