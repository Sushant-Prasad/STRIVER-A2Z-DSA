class Solution {
    /**
     * Function to check if the given array is sorted in non-decreasing order.
     *
     * Approach:
     * ---------
     * - Iterate through the array from index 0 to n-2.
     * - For each pair of adjacent elements arr[i] and arr[i+1]:
     *     → If arr[i+1] < arr[i], then the array is not sorted.
     * - If no such violation is found, the array is sorted.
     *
     * Example:
     * --------
     * Input: [1, 2, 3, 4, 5]
     * Output: true
     *
     * Input: [3, 5, 2, 6]
     * Output: false (since 2 < 5)
     *
     * Time Complexity: O(n) → single traversal
     * Space Complexity: O(1) → constant extra space
     */
    public boolean isSorted(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            // If next element is smaller, array is not sorted
            if (arr[i + 1] < arr[i]) {
                return false;
            }
        }
        return true; // No violation found → sorted
    }
}

1752. Check if Array Is Sorted and Rotated
class Solution {
    /**
     * Function to check if the array is sorted and rotated.
     * 
     * Approach:
     * - Traverse the array and count the number of "peak"
     *   where nums[i] > nums[(i+1) % n].
     * - If there is:
     *    → 0 peak → array is sorted (not rotated).
     *    → 1 peak → array is sorted and rotated.
     *    → >1 peaks → not sorted & rotated.
     *
     * Example:
     * [3,4,5,1,2] → one peak (5 > 1) → true
     * [1,2,3,4,5] → zero peaks → true
     * [2,1,3,4]   → two peaks → false
     */
    public boolean check(int[] nums) {
        int n = nums.length;
        int peak = 0;

        for (int i = 0; i < n; i++) {
            if (nums[i] > nums[(i + 1) % n]) {
                peak++;
            }
        }

        return peak <= 1; // allow 0 (sorted) or 1 (sorted+rotated)
    }
}

