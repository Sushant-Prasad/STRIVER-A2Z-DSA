//link:-https://leetcode.com/problems/rotate-array/
======================================== APROACH-1 =========================================================================
// Link: https://leetcode.com/problems/rotate-array/

/*
===========================================================
TITLE
===========================================================
Rotate Array (Right Rotation by K Steps)

===========================================================
PROBLEM STATEMENT
===========================================================
You are given an integer array `nums` and an integer `k`.

Rotate the array to the **right by k steps**, where `k` is non-negative.

The rotation must be done **in-place** (modify the input array).

Input:
• int[] nums → array of integers
• int k → number of steps to rotate

Output:
• Modified array rotated to the right by k positions

Constraints:
• 1 ≤ nums.length ≤ 10⁵
• -2³¹ ≤ nums[i] ≤ 2³¹ - 1
• 0 ≤ k ≤ 10⁵

Edge Cases:
• k = 0 (no rotation)
• k > nums.length
• nums contains one element
• nums contains duplicate values

===========================================================
INTUITION
===========================================================
• Rotating by `n` steps (array length) gives the same array
• So we normalize k using k % n
• There are multiple ways to rotate:
  - Using extra space (simpler)
  - Using reversal algorithm (optimal, in-place)

===========================================================
APPROACH – 1 (Using Extra Space)
===========================================================
1) Normalize k = k % n
2) Store last k elements in a temporary list
3) Shift first (n-k) elements to the right by k positions
4) Copy stored elements back to the beginning

Pros:
• Easy to understand

Cons:
• Uses extra space O(k)

===========================================================
APPROACH – 2 (Reversal Algorithm – Optimal)
===========================================================
1) Normalize k = k % n
2) Reverse the entire array
3) Reverse first k elements
4) Reverse remaining n-k elements

This results in correct right rotation using O(1) space.

===========================================================
EXAMPLE
===========================================================
Input:
nums = [1,2,3,4,5,6,7], k = 3

Output:
[5,6,7,1,2,3,4]

===========================================================
TIME COMPLEXITY
===========================================================
Approach 1:
• O(n) → shifting elements

Approach 2:
• O(n) → three reversals

===========================================================
SPACE COMPLEXITY
===========================================================
Approach 1:
• O(k) → temporary storage

Approach 2:
• O(1) → in-place rotation

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• Always normalize k using k % n
• Reversal algorithm is the most optimal solution
• Approach 2 is preferred in interviews
===========================================================
*/

class Solution {

    /* ===================== APPROACH 1 ===================== */

    /*
     * Rotates the array using extra space
     */
    public void rotate(int[] nums, int k) {

        int n = nums.length;

        // Normalize k
        k = k % n;

        // No rotation needed
        if (k == 0) return;

        // Store last k elements
        ArrayList<Integer> temp = new ArrayList<>();
        for (int i = n - k; i < n; i++) {
            temp.add(nums[i]);
        }

        // Shift remaining elements to the right
        for (int i = n - k - 1; i >= 0; i--) {
            nums[i + k] = nums[i];
        }

        // Copy stored elements back
        for (int i = 0; i < k; i++) {
            nums[i] = temp.get(i);
        }
    }
}

======================================== APROACH-2 =========================================================================
/*
===========================================================
TITLE
===========================================================
Rotate Array Using Reversal Algorithm

===========================================================
PROBLEM STATEMENT
===========================================================
You are given an integer array `nums` and a non-negative integer `k`.

Your task is to rotate the array to the **right by k steps**.
The rotation must be performed **in-place**, without using extra space
proportional to the size of the array.

Input:
• int[] nums → input array
• int k → number of steps to rotate

Output:
• Modified array rotated to the right by k positions

Constraints:
• 1 ≤ nums.length ≤ 10⁵
• 0 ≤ k ≤ 10⁵
• Array may contain duplicate values

Edge Cases:
• k = 0 → array remains unchanged
• k ≥ nums.length → rotation cycles back
• Array with a single element

===========================================================
INTUITION
===========================================================
• Rotating the array by k steps can be broken into rearranging segments
• Reversing parts of the array helps reposition elements efficiently
• Since reversing is in-place, we achieve optimal space usage
• Normalizing k using k % n avoids unnecessary full rotations

===========================================================
APPROACH (REVERSAL ALGORITHM)
===========================================================
1) Normalize k = k % n
2) Reverse the entire array
3) Reverse the first k elements
4) Reverse the remaining n - k elements

After these steps, the array becomes correctly rotated to the right.

===========================================================
EXAMPLE
===========================================================
Input:
nums = [1,2,3,4,5,6,7], k = 3

Step 1: Reverse entire array
→ [7,6,5,4,3,2,1]

Step 2: Reverse first k elements
→ [5,6,7,4,3,2,1]

Step 3: Reverse remaining elements
→ [5,6,7,1,2,3,4]

Output:
[5,6,7,1,2,3,4]

===========================================================
TIME COMPLEXITY
===========================================================
O(n)
• Entire array is reversed once
• Two partial reversals cover all elements

===========================================================
SPACE COMPLEXITY
===========================================================
O(1)
• In-place algorithm
• No extra data structures used

===========================================================
SPECIAL NOTES FOR LOGIC
===========================================================
• Reversal algorithm is the most optimal solution
• Always normalize k before processing
• Helper reverse function simplifies logic
• This approach is preferred in interviews
===========================================================
*/

class Solution {

    /*
     * Helper function to reverse a subarray in-place
     * between indices s and e (inclusive)
     */
    private void reverse(int[] arr, int s, int e) {

        // Swap elements from both ends until pointers meet
        while (s < e) {
            int temp = arr[s];
            arr[s] = arr[e];
            arr[e] = temp;
            s++;
            e--;
        }
    }

    /*
     * Rotates the array to the right by k steps
     * using the reversal algorithm
     */
    public void rotate(int[] nums, int k) {

        int n = nums.length;

        // Normalize k to avoid redundant full rotations
        k = k % n;

        // If no rotation is needed
        if (k == 0) return;

        // Step 1: Reverse the entire array
        reverse(nums, 0, n - 1);

        // Step 2: Reverse the first k elements
        reverse(nums, 0, k - 1);

        // Step 3: Reverse the remaining elements
        reverse(nums, k, n - 1);
    }
}

